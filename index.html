<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="终身学习">
<meta property="og:type" content="website">
<meta property="og:title" content="Christiecui的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Christiecui的博客">
<meta property="og:description" content="终身学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="christiecui">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Christiecui的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Christiecui的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/02/%E4%BB%8E%E9%9B%B6%E5%8D%95%E5%AD%A6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A53-ASM%20%E5%AF%B9lambda%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="christiecui">
      <meta itemprop="description" content="终身学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Christiecui的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/02/%E4%BB%8E%E9%9B%B6%E5%8D%95%E5%AD%A6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A53-ASM%20%E5%AF%B9lambda%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84hook/" class="post-title-link" itemprop="url">从零单学跨平台无埋点上报3-ASM对lambda语法糖的hook</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-02 15:18:15" itemprop="dateCreated datePublished" datetime="2023-11-02T15:18:15+08:00">2023-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:59:03" itemprop="dateModified" datetime="2023-11-03T16:59:03+08:00">2023-11-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从零单学跨平台无埋点上报3-ASM-对lambda语法糖的hook"><a href="#从零单学跨平台无埋点上报3-ASM-对lambda语法糖的hook" class="headerlink" title="从零单学跨平台无埋点上报3-ASM 对lambda语法糖的hook"></a>从零单学跨平台无埋点上报3-ASM 对lambda语法糖的hook</h1><h2 id="一、Previous-Review"><a href="#一、Previous-Review" class="headerlink" title="一、Previous Review"></a>一、Previous Review</h2><p>上篇我们站在实战的角度，讲述了无埋点插桩方法的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//Log.i(&quot;testMethod&quot;,&quot;Hello ASM&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但此时遇到了难题，对于一个基本的onclick事件的上报，如果没有方法名，我们该如何找到hook的点？</p>
<h2 id="二、挑战：hook不到lambda"><a href="#二、挑战：hook不到lambda" class="headerlink" title="二、挑战：hook不到lambda"></a>二、挑战：hook不到lambda</h2><p>先来看看几种写法</p>
<h3 id="内部类写法"><a href="#内部类写法" class="headerlink" title="内部类写法"></a>内部类写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.<span class="title function_">setOnClickListener</span>(<span class="keyword">new</span> <span class="title class_">View</span>.<span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">onClick</span>(<span class="params">View v</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如上面这种常规的匿名内部类写法，实际编译的时候，会生成一个内部类，这个内部类里有</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass$1</span> implements <span class="title class_">View</span>.<span class="property">OnClickListener</span>&#123;</span><br><span class="line">   @<span class="title class_">Override</span></span><br><span class="line">   public <span class="keyword">void</span> <span class="title function_">onClick</span>(<span class="params">View v</span>) &#123;</span><br><span class="line">   	<span class="comment">// do something</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候通过插桩扫描，我们就可以通过如下判断是否命中：</p>
<ul>
<li>实现了<code>View.OnClickListener</code> 接口</li>
<li>当前扫描的方法是 <code>onClick(View v)</code></li>
</ul>
<p>通过上面两个判断，就可以找到我们要插桩的方法，然后我们进行插桩就可以了</p>
<p>但是实际应用的时候我们发现，除了上面常规的写法，还会遇到一些简写方式：</p>
<h3 id="lambda表达式写法"><a href="#lambda表达式写法" class="headerlink" title="lambda表达式写法"></a>lambda表达式写法</h3><ul>
<li><p>如常见的<code>lambda</code>表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener&#123; view -&gt; </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者<strong>SAM转换</strong>为更简单的形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的写法通过<strong>“onClick”</strong>来找hook函数是找不到的，下面我们要分析为何hook不到？原因很简单：<strong>语法糖的原因</strong>，其实他是dosomething是没有承载他的函数的，被优化了，这叫做<strong>SAM转换</strong></p>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-7dcd2746c77ef5b6a7a5a8a6ae44c78d_1440w.webp" alt="img"></p>
<p>根据图所示，自定义的 Android 插件是在 D8&#x2F;R8 之前先操作 .class 文件。D8 是 Android 提供的脱糖工具，这就导致自定义插件获取的 .class 是原始未脱糖的 .class</p>
<p>因此我们需要做的事<strong>脱糖后，找到相关的方法</strong></p>
<h2 id="三、-找到lambda方法"><a href="#三、-找到lambda方法" class="headerlink" title="三、 找到lambda方法"></a>三、 找到lambda方法</h2><p>首先我们先看，lamdba表达式写法，对应上面的例子，为了做无埋点的点击事件插桩，我们写了一个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">        <span class="type">val</span> <span class="variable">button</span> <span class="operator">=</span> findViewById&lt;Button&gt;(R.id.button)</span><br><span class="line">          </span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            print(<span class="string">&quot;hello lambda&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用ASM view工具看看字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methodVisitor = classWriter.visitMethod(ACC_PROTECTED, <span class="string">&quot;onCreate&quot;</span>, <span class="string">&quot;(Landroid/os/Bundle;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">.......</span><br><span class="line">methodVisitor.visitInvokeDynamicInsn(<span class="string">&quot;onClick&quot;</span>, <span class="string">&quot;()Landroid/view/View$OnClickListener;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Handle</span>(Opcodes.H_INVOKESTATIC, <span class="string">&quot;java/lang/invoke/LambdaMetafactory&quot;</span>, <span class="string">&quot;metafactory&quot;</span>, <span class="string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>, <span class="literal">false</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;Type.getType(<span class="string">&quot;(Landroid/view/View;)V&quot;</span>), <span class="keyword">new</span> <span class="title class_">Handle</span>(Opcodes.H_INVOKESTATIC, <span class="string">&quot;com/example/moduletest/SecondActivity&quot;</span>, <span class="string">&quot;onCreate$lambda$0&quot;</span>, <span class="string">&quot;(Landroid/view/View;)V&quot;</span>, <span class="literal">false</span>), Type.getType(<span class="string">&quot;(Landroid/view/View;)V&quot;</span>)&#125;);</span><br><span class="line">methodVisitor.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;android/widget/Button&quot;</span>, <span class="string">&quot;setOnClickListener&quot;</span>, <span class="string">&quot;(Landroid/view/View$OnClickListener;)V&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methodVisitor = classWriter.visitMethod(ACC_PRIVATE | ACC_FINAL | ACC_STATIC, &quot;onCreate$lambda$0&quot;, &quot;(Landroid/view/View;)V&quot;, null, null);</span><br><span class="line">methodVisitor.visitCode();</span><br><span class="line">methodVisitor.visitLdcInsn(&quot;hello lambda&quot;);</span><br><span class="line">methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);</span><br><span class="line">methodVisitor.visitInsn(SWAP);</span><br><span class="line">methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;print&quot;, &quot;(Ljava/lang/Object;)V&quot;, false);</span><br><span class="line">methodVisitor.visitInsn(RETURN);</span><br><span class="line">methodVisitor.visitMaxs(2, 1);</span><br><span class="line">methodVisitor.visitEnd();</span><br></pre></td></tr></table></figure>

<p>从上面的字节码我们可以看出onclick相关方法中多了一些奇怪的东西</p>
<ul>
<li>visitInvokeDynamicInsn</li>
<li>LambdaMetafactory</li>
<li>metafactory</li>
<li>MethodType</li>
<li>CallSite</li>
<li>onCreate$lambda$0</li>
</ul>
<h3 id="Invokedynamic-指令"><a href="#Invokedynamic-指令" class="headerlink" title="Invokedynamic 指令"></a>Invokedynamic 指令</h3><p>在正式介绍如何使用 ASM 处理 Lambda 和方法引用之前，我们首先了解一下字节码指令 <em><strong>invokedynamic*<strong>。</strong>invokedynamic</strong> 指令是在 JDK 7 引入的，用来实现动态类型语言功能，简单来说就是能够在运行时去调用实际的代码。在进一步介绍 invokedynamic 指令之前，我们先熟悉几个类：</em><strong>MethodType、MethodHandle、CallSite* 。</strong>在介绍这几个类之前我们先来了解一个方法的构成：</p>
<ul>
<li>方法名；</li>
<li>方法签名（参数类型和返回值类型）；</li>
<li>方法所在的类；</li>
<li>方法体（方法中的代码）。</li>
</ul>
<p>根据上面方法的构成，我们来依次介绍上面的几个类的用法。</p>
<p>** MethodType**</p>
<p>MethodType 代表一个方法所需的参数签名和返回值签名，MethodType 类有多个静态方法来构造 MethodType 对象，示例如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodType methodType = MethodType.methodType(String.class, int.class);</span><br></pre></td></tr></table></figure>

<p>上面这个 MethodType 描述的是返回值为 String 类型，参数是一个 int 类型的方法签名，例如：int foo(String) 这个方法就符合这个描述。</p>
<p><strong>MethodHandle</strong></p>
<p>MethodHandle 翻译过来就是方法句柄，通过这个句柄可以调用相应的方法，MethodType 描述了方法的参数和返回值，MethodHandle 则是根据类名、方法名并且配合 MethodType 来找到特定方法然后执行它；MethodType 和 MethodHandle 配合起来完整表达了一个方法的构成。例如：我们调用 String.valueOf(int) 方法，可以这么做：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//声明参数和返回值类型</span><br><span class="line">MethodType methodType = MethodType.methodType(String.class, int.class);</span><br><span class="line">MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">//声明一个方法句柄：这里说明的是 String 类里面的 valueOf 方法，方法签名需要符合 methodType</span><br><span class="line">MethodHandle methodHandle = lookup.findStatic(String.class, &quot;valueOf&quot;, methodType);</span><br><span class="line">//执行这个方法</span><br><span class="line">String result = (String) methodHandle.invoke(99);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>这个跟反射很类似，从这个例子可以看出方法句柄里包含了需要执行的方法信息，只要传入所需的参数就可以执行这个方法了。</p>
<p><strong>CallSite</strong></p>
<p>CallSite 是方法调用点，调用点中包含了方法句柄信息，通常 invokedynamic 指令所描述的内容会使用 CallSite 来链接，关于这块内容的介绍也可以在 「<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzA3ODUxNTI0OA==&mid=2247483787&idx=1&sn=dc6e6d44acd0576ee302db0466e8ffc2&chksm=9f40dcd4a83755c2857ab430391eafa67bb759b9fe73bd089436db7f6361b1d2f141baea8562&mpshare=1&scene=1&srcid=0706Fg6ZgHHalkgWPeuhFqst&sharer_sharetime=1594032485178&sharer_shareid=91828d0acaf1810230db571b9bb3b38f&rd2werd=1%23wechat_redirect">Lambda 设计参考</a>」找到。可以从调用点上获取 MethodHandle ，代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CallSite callSite = new ConstantCallSite(methodHandle);</span><br><span class="line">MethodHandle mh = callSite.getTarget();</span><br></pre></td></tr></table></figure>

<p><strong>LambdaMetafacotry.metafactory</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static CallSite metafactory(MethodHandles.Lookup caller,</span><br><span class="line">                                       String invokedName,</span><br><span class="line">                                       MethodType invokedType,</span><br><span class="line">                                       MethodType samMethodType,</span><br><span class="line">                                       MethodHandle implMethod,</span><br><span class="line">                                       MethodType instantiatedMethodType)</span><br></pre></td></tr></table></figure>

<p>这个方法会返回一个 Callsite 调用点，调用点中包括了方法句柄信息，我们现在来详细解释下这个方法的参数，其中前三个参数不需要关注，系统会自动生成，主要是看后面三个参数：</p>
<ul>
<li><strong>samMethodType</strong>: 函数式接口中抽象方法的签名描述信息，关于 MethodType 前面的章节有介绍，这里的方法签名是 Consumer#apply 的签名，因为泛型参数，泛型 T 统一被转换成 Object（注：这里的 sam 指的是 Single Abstract Method，大家可以理解为函数式接口）；</li>
<li><strong>implMethod</strong>: 是一个方法句柄，这个在前面也介绍了，方法句柄包含了具体需要执行的方法，从上面的字节码可以看到，这个方法句柄的内容是：#23 invokestatic cn&#x2F;curious&#x2F;asm&#x2F;method_ref&#x2F;TestMain2.lambda$main$0:(Ljava&#x2F;lang&#x2F;String;)V，意思是调用静态方法 lambda$main$0，在前面有介绍 Lambda 脱糖的时候我们知道，Lambda 会生成一个方法，此方法默认是隐藏的，如果想查看，可以使用 java 的 javap -p -v xxx.class 命令查看这个方法；</li>
<li><strong>instantiatedMethodType</strong>: 是 samMethodType 的具体实现，源码传入的泛型类型是 String，所以这里就是 String。</li>
</ul>
<h3 id="使用ASM实现Hook"><a href="#使用ASM实现Hook" class="headerlink" title="使用ASM实现Hook"></a>使用ASM实现Hook</h3><p><strong>我们知道方法句柄中包含了方法调用的信息，而且我们也说明了方法引用并不会生成一个 lambda$ 开头的中间方法，同时我们知道 MethodHandle 包含了方法调用的信息。因此，如果要去 Hook Lambda 和方法引用，我们可以创建一个新的 MethodHandle 替换原有的。具体做法是：我们会生成一个新的方法，新的方法中会实现 invokedynamic 指令中描述的代码逻辑。然后创建新的 MethodHandle，将这个 MethodHandle 替换原本的 MethodHandle</strong>。</p>
<p>简化成伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="comment">//原始匿名内部类实现</span></span><br><span class="line">view.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;hello lambda&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.遍历InvokeDynamicInsn，因为onclick方法此时已经不会被编译出来，所以要先找到来匹配我们的需要onclick插桩的规则</span></span><br><span class="line">SAMMethodClass = android/view/<span class="type">View$OnClickListener</span></span><br><span class="line"><span class="variable">SAMMethodName</span> <span class="operator">=</span> onClick</span><br><span class="line">  </span><br><span class="line"><span class="comment">//2.找到生成方法</span></span><br><span class="line"><span class="type">val</span> <span class="variable">generateMethodNameAndDesc</span> <span class="operator">=</span> oldHandle.name + oldHandle.desc</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line"><span class="comment">//3.所以伪代码就是</span></span><br><span class="line">view.setOnClickListener(<span class="keyword">new</span> <span class="title class_">SAMMethodClass</span>()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onCreate$lambda$<span class="number">0</span>(View v) &#123;</span><br><span class="line">        println(<span class="string">&quot;hello lambda&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="AsmClassVisitorFactory实现"><a href="#AsmClassVisitorFactory实现" class="headerlink" title="AsmClassVisitorFactory实现"></a>AsmClassVisitorFactory实现</h4><p>如下文章使用AsmClassVisitorFactory进行插桩，上述寻找DynamicInsn和匹配实现的比较清晰，可以参考</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7042328862872567838">https://juejin.cn/post/7042328862872567838</a></p>
<h4 id="Asm-Transform实现"><a href="#Asm-Transform实现" class="headerlink" title="Asm Transform实现"></a>Asm Transform实现</h4><ol>
<li>复写该函数，找到我们想要hook的中间方法，并用Map记录</li>
</ol>
<p><code>public void visitInvokeDynamicInsn(String samMethodName, String descriptor,                                   Handle bootstrapMethodHandle, Object... bsmArgs)</code></p>
<p>2.复现<code>public void visitCode() </code></p>
<p>在中间方法进入的时候对中间方法进行插桩</p>
<h2 id="四、将点击的View进行hook"><a href="#四、将点击的View进行hook" class="headerlink" title="四、将点击的View进行hook"></a>四、将点击的View进行hook</h2><h3 id="1-将View的id作为参数"><a href="#1-将View的id作为参数" class="headerlink" title="1.将View的id作为参数"></a>1.将View的id作为参数</h3><p>无埋点上报，最关键的不仅仅是在onclick的方法进行上报，还必须将View的id作为上报的position上报上去，在我们开开心心的准备写入时，再回头看看原来的方法如果是<strong>匿名内部类</strong>如何获取view</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>找到onclick方法</li>
<li>将View v作为参数，传递给hook的函数</li>
</ol>
<p>如果是lamda表达式，或者<strong>SAM转换</strong>为更简单的形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener&#123; view -&gt; </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">view.setOnClickListener&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(<span class="keyword">new</span> <span class="title class_">SAMMethodClass</span>()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onCreate$lambda$<span class="number">0</span>(View v) &#123;</span><br><span class="line">        println(<span class="string">&quot;hello lambda&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>找到onCreate$lambda$0方法</li>
<li>将View v作为参数，传递给hook的函数</li>
</ol>
<p>​    String a &#x3D; this.mParam1;</p>
<h3 id="2-隐式This-指针的坑"><a href="#2-隐式This-指针的坑" class="headerlink" title="2.隐式This 指针的坑"></a>2.隐式This 指针的坑</h3><h3 id="1）-问题发现"><a href="#1）-问题发现" class="headerlink" title="1） 问题发现"></a>1） 问题发现</h3><p>当我们将如下函数作为hook函数进行上报时，在apply工程中发生了crash，经过定位与this指针有关</p>
<p>示例代码,假如我们要插入printViewid函数 , 其中printViewid <strong>是一个java的static函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lambda.setOnClickListener(view -&gt; &#123;</span><br><span class="line">    Test.printViewid(v)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们用如下代码查看下</p>
<p><img src="https://p.ipic.vip/uimv4x.png" alt="image-20231103155128261"></p>
<p>稍微增加一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lambda.setOnClickListener(view -&gt; &#123;</span><br><span class="line">    <span class="built_in">this</span>.application</span><br><span class="line">    Test.printViewid(v)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://p.ipic.vip/qmv76f.png" alt="image-20231103155307866"></p>
<p><strong>view函数ALOAD的index是变动的，这该如何插入到我们预定的插桩函数中？</strong></p>
<h3 id="2）原因"><a href="#2）原因" class="headerlink" title="2）原因"></a>2）原因</h3><p><strong>不得复习下</strong> 从零单学跨平台无埋点上报的 ASM 准备知识中的内容</p>
<p><img src="https://p.ipic.vip/kkjrdy.jpg" alt="img"></p>
<p>文件里我们可以看到属性中包含2个部分:</p>
<ul>
<li><strong>Code 区</strong>: 源代码对应的 JVM 指令操作码，我们在字节码增强的时候重点操作的就是这个部分。</li>
<li><strong>LineNumberTable</strong>: 型号表，将 Code 区的操作码和源代码的行号对应，Debug 时会起到作用（即: 当源代码向下走一行，相应的需要走几个 JVM 指令操作码）。</li>
</ul>
<p>一般情况下还会包括本地变量表。**</p>
<ul>
<li><strong>LocalVariableTable</strong>: 本地变量表，包含 this 和局部变量，之所以可以在每一个<strong>非 static</strong> 的方法内部都可以调用到 this，<strong>是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。</strong></li>
</ul>
<p><strong>如果我们的Hook插入的方法是static方法，不会默认把static方法传入，当里面包含this指针后，才会把this指针传入，因此，因此我们的ALOAD是变化的，</strong>所以更改的方案有两个</p>
<ol>
<li>把hook的方法改为非static方法， JVM 将 this 作为每个方法的第一个参数隐式进行传入。</li>
<li>遍历LocalVariableTable，当变量名为需要的hook的参数时，比如<code>Landroid/view/View;</code>，记录index，后续将index传给ALOAD</li>
</ol>
<h2 id="五、全文总结"><a href="#五、全文总结" class="headerlink" title="五、全文总结"></a>五、全文总结</h2><p>本文介绍了：如果用ASM框架处理lambda表达式，用来应对kotlin中的onclick语法糖的问题</p>
<p>后续的文章会从如果hook <strong>C++代码来进一步进行无埋点上报</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/159286720">https://zhuanlan.zhihu.com/p/159286720</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/leavesCZY/asm-samples">https://github.com/leavesCZY/asm-samples</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7127563086566785038">https://juejin.cn/post/7127563086566785038</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/01/%E4%BB%8E%E9%9B%B6%E5%8D%95%E5%AD%A6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A51-ASM%20%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="christiecui">
      <meta itemprop="description" content="终身学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Christiecui的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/01/%E4%BB%8E%E9%9B%B6%E5%8D%95%E5%AD%A6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A51-ASM%20%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">从零单学跨平台无埋点上报1-ASM准备知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-01 21:57:00 / 修改时间：22:04:35" itemprop="dateCreated datePublished" datetime="2023-11-01T21:57:00+08:00">2023-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从零单学跨平台无埋点上报1-ASM-准备知识"><a href="#从零单学跨平台无埋点上报1-ASM-准备知识" class="headerlink" title="从零单学跨平台无埋点上报1 - ASM 准备知识"></a>从零单学跨平台无埋点上报1 - ASM 准备知识</h1><h2 id="1、Why-ASM"><a href="#1、Why-ASM" class="headerlink" title="1、Why ASM"></a>1、Why ASM</h2><p>【方案对比】开门见山，无埋点上报，字节码增强优于反射与监听</p>
<p><img src="https://p.ipic.vip/cj7t01.jpg" alt="6b949209db8b4c2a912881d93e602a4c"></p>
<p>【反射&#x2F;监听】优点：开发简单，上线快 缺点：性能损耗，拓展差<br>【字节码增强】优点：性能消耗小，拓展好 缺点：开发门槛高</p>
<h2 id="2、What-is-ASM"><a href="#2、What-is-ASM" class="headerlink" title="2、What is ASM"></a>2、What is ASM</h2><p><strong>简单来说，ASM是一个“在编译时”操作Java字节码的类库</strong><br>其他的类库也有AspectJ，ReDex，他们广泛的应用于切面编程（AOP），属于切面框架，为了能够更好的理解ASM是什么，可以从下面三个方面来解释</p>
<h3 id="1）ASM能做什么"><a href="#1）ASM能做什么" class="headerlink" title="1）ASM能做什么"></a>1）ASM能做什么</h3><h4 id="ASM框架的原理"><a href="#ASM框架的原理" class="headerlink" title="ASM框架的原理"></a>ASM框架的原理</h4><p>一个.java文件经过Java编译器（javac）编译之后会生成一个.class文件。在.class文件中，存储的是字节码（ByteCode）数据，如下图所示。ASM所的操作对象是是字节码（ByteCode），而在许多情况下，字节码（ByteCode）的具体表现形式是.class文件。</p>
<img src="https://p.ipic.vip/o597o6.png" alt="image-20231020114023027" style="zoom:50%;" />

<h4 id="ASM能做什么"><a href="#ASM能做什么" class="headerlink" title="ASM能做什么"></a>ASM能做什么</h4><p>父类：修改成一个新的父类<br>接口：添加一个新的接口、删除已有的接口<br>字段：添加一个新的字段、删除已有的字段<br>方法：添加一个新的方法、删除已有的方法、修改已有的方法</p>
<p><img src="https://lsieun.github.io/assets/images/java/asm/what-asm-can-do.png" alt="What ASM Can Do"></p>
<h4 id="为什么要用ASM"><a href="#为什么要用ASM" class="headerlink" title="为什么要用ASM"></a>为什么要用ASM</h4><p>这里就不得不对比下编译插桩的三个方式，通过对比来说，<strong>在无埋点覆盖率的指标下，用ASM是最佳的选择</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>AspectJ</td>
<td>字节码处理元老，成熟稳定，使用简单</td>
<td>覆盖率不足，只有ASM的50%，性能差</td>
</tr>
<tr>
<td>ASM</td>
<td>操作灵活，效率高，覆盖率高</td>
<td>上手难</td>
</tr>
<tr>
<td>ReDex</td>
<td>提供了一个简单的 Method Tracing 和 Block Tracing 工具，这个工具可以在所有方法或者指定方法前面插入一段跟踪代码，主要用于安全逆向</td>
<td>ReDex 的这个功能并不是完整的 AOP 工具，但它提供了一系列指令生成 API 和 Opcode 插入 API</td>
</tr>
</tbody></table>
<h4 id="ASM架构"><a href="#ASM架构" class="headerlink" title="ASM架构"></a>ASM架构</h4><p><img src="https://lsieun.github.io/assets/images/java/asm/asm-components.png" alt="ASM Components"></p>
<p>从组成结构上来说，ASM分成两部分，一部分为Core API，另一部分为Tree API。</p>
<ul>
<li><p>其中，Core API包括<code>asm.jar</code>、<code>asm-util.jar</code>和<code>asm-commons.jar</code>；</p>
</li>
<li><p>其中，Tree API包括<code>asm-tree.jar</code>和<code>asm-analysis.jar</code>。</p>
</li>
<li><p>Tree API的优势:</p>
<ul>
<li>易用性：如果一个人在之前并没有接触过Core API和Tree API，那么Tree API更容易入手。</li>
<li>功能性：在实现比较复杂的功能时，Tree API比Core API更容易实现。</li>
</ul>
</li>
<li><p>Core API的优势：</p>
<ul>
<li>执行效率：在实现相同功能的前提下，Core API要比Tree API执行效率高，花费时间少。</li>
<li>内存使用：Core API比Tree API占用的内存空间少。</li>
</ul>
</li>
</ul>
<p>*<em>在ASM无埋点插桩中，优先考虑使用Tree API。</em>，其原理如下</p>
<img src="https://p.ipic.vip/hgmk56.jpg" alt="img" style="zoom:50%;" />



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>第一点，ASM所处理对象是字节码数据，也可以直观的理解成.class文件，不是.java文件。</p>
</li>
<li><p>第二点，ASM能够对字节码数据进行哪些操作呢？回答：analyze、generate、transform。</p>
</li>
<li><p>第三点，ASM可以形象的理解为“Java语言世界”的边缘上一扇大门，通过这扇大门，可以帮助我们进入到“字节码的世界”。</p>
</li>
<li><p>第四点，ASM虽然上手难，但是在不断迭代和API优化，他操作灵活，效率高，覆盖率高</p>
</li>
</ul>
<h2 id="3、How-to-use-ASM"><a href="#3、How-to-use-ASM" class="headerlink" title="3、How to use ASM"></a>3、How to use ASM</h2><p>根据上文整体的介绍，ASM与AspectJ相比，其缺点就是<em><strong>难</strong></em>，那么由于篇幅有限与知识的接受程度，这里优先抛出一个需要学习ASM的学习框架，便于大家理解最终目标**”终端如何实现ASM去进行无埋点插桩”**还有多少路要走</p>
<p><img src="https://p.ipic.vip/e3qtn6.png" alt="image-20230915171248173"></p>
<h3 id="Android打包原理"><a href="#Android打包原理" class="headerlink" title="Android打包原理"></a>Android打包原理</h3><h4 id="打包原理介绍"><a href="#打包原理介绍" class="headerlink" title="打包原理介绍"></a>打包原理介绍</h4><img src="https://p.ipic.vip/zxq0ym.png" alt="img" style="zoom:50%;" />

<p>1、aapt先编译资源（res目录里面的哪些）然后生成编译后的resources和R.java文件</p>
<p>2、aidl 会处理aidl文件生成 java的一些接口java</p>
<p>3、我们App自己的java文件（自己写的，sdk里的）</p>
<p>4、所有的java文件 会被java Compiler编程成 .class文件</p>
<p>5 、<strong>所有class会被dex优化打包成dex文件 供Delvik虚拟机使用。</strong></p>
<p>6、apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分</p>
<p>7、签名再打包</p>
<h4 id="class如何打包成-dex"><a href="#class如何打包成-dex" class="headerlink" title="class如何打包成.dex"></a>class如何打包成.dex</h4><img src="https://p.ipic.vip/npbw4v.png" alt="img" style="zoom:30%;" />

<p>在安卓APK编译种，class到dex会通过Gradle Task的一个个Transform，每一个Transform实际上是一个gradle Task</p>
<h3 id="字节码是什么"><a href="#字节码是什么" class="headerlink" title="字节码是什么"></a>字节码是什么</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>Java 是平台无关的语言，但 JVM 却不是跨平台的，不同平台的 JVM 帮我们屏蔽了平台的差异。不同平台的 JVM 加载和执行同一种平台无关的字节码。之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。</p>
<h4 id="2、字节码组成"><a href="#2、字节码组成" class="headerlink" title="2、字节码组成"></a>2、字节码组成</h4><ul>
<li><strong>操作码（Opcode）</strong>：一个字节长度（0-255），代表着某种特定的操作含义。</li>
<li><strong>操作数（Operands）</strong>：零个或者多个，紧跟在操作码之后，代表此操作需要的参数。</li>
</ul>
<h4 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a>3、特点</h4><ul>
<li><p>为了获取短小精悍的字节码文件，限定了Java虚拟机操作码的长度为1个字节，指令集的操作码不能超过256条；</p>
</li>
<li><p>Class文件放弃了编译后代码中操作数长度对齐，可以省略很多填充和间隔符号。但这也意味者虚拟机处理那些超过一个字节数据的时候，不得不在运行的时候从字节码中重建出具体数据的结构；</p>
<p>由于对于初学者较难直接理解，我们通过一个例子来讲解</p>
<p>【字节码分析】</p>
<p>下面定义一个简单的 Java 类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a + b - c;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>借助工具（后面再讲什么工具好用）变成字节码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Last</span> modified <span class="number">2021</span>-<span class="number">8</span>-<span class="number">22</span>; size <span class="number">702</span> bytes</span><br><span class="line">  <span class="title class_">MD5</span> checksum 86c824b56f7eef2ec5cc5275232b93eb</span><br><span class="line">  <span class="title class_">Compiled</span> <span class="keyword">from</span> <span class="string">&quot;SimpleClass.java&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wz</span>.<span class="property">run</span>.<span class="property">SimpleClass</span></span><br><span class="line">  minor <span class="attr">version</span>: <span class="number">0</span></span><br><span class="line">  major <span class="attr">version</span>: <span class="number">52</span></span><br><span class="line">  <span class="attr">flags</span>: <span class="variable constant_">ACC_SUPER</span></span><br><span class="line"><span class="title class_">Constant</span> <span class="attr">pool</span>:</span><br><span class="line">   #<span class="number">1</span> = <span class="title class_">Methodref</span>          #<span class="number">6.</span>#<span class="number">26</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = <span class="title class_">Fieldref</span>           #<span class="number">5.</span>#<span class="number">27</span>         <span class="comment">// wz/run/SimpleClass.c:I</span></span><br><span class="line">   #<span class="number">3</span> = <span class="title class_">Fieldref</span>           #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = <span class="title class_">Methodref</span>          #<span class="number">30.</span>#<span class="number">31</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">5</span> = <span class="title class_">Class</span>              #<span class="number">32</span>            <span class="comment">// wz/run/SimpleClass</span></span><br><span class="line">   #<span class="number">6</span> = <span class="title class_">Class</span>              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = <span class="title class_">Utf8</span>               c</span><br><span class="line">   #<span class="number">8</span> = <span class="title class_">Utf8</span>               I</span><br><span class="line">   #<span class="number">9</span> = <span class="title class_">Utf8</span>               &lt;init&gt;</span><br><span class="line">  #<span class="number">10</span> = <span class="title class_">Utf8</span>               ()V</span><br><span class="line">  #<span class="number">11</span> = <span class="title class_">Utf8</span>               <span class="title class_">Code</span></span><br><span class="line">  #<span class="number">12</span> = <span class="title class_">Utf8</span>               <span class="title class_">LineNumberTable</span></span><br><span class="line">  #<span class="number">13</span> = <span class="title class_">Utf8</span>               <span class="title class_">LocalVariableTable</span></span><br><span class="line">  #<span class="number">14</span> = <span class="title class_">Utf8</span>               <span class="variable language_">this</span></span><br><span class="line">  #<span class="number">15</span> = <span class="title class_">Utf8</span>               <span class="title class_">Lwz</span>/run/<span class="title class_">SimpleClass</span>;</span><br><span class="line">  #<span class="number">16</span> = <span class="title class_">Utf8</span>               add</span><br><span class="line">  #<span class="number">17</span> = <span class="title class_">Utf8</span>               ()I</span><br><span class="line">  #<span class="number">18</span> = <span class="title class_">Utf8</span>               a</span><br><span class="line">  #<span class="number">19</span> = <span class="title class_">Utf8</span>               b</span><br><span class="line">  #<span class="number">20</span> = <span class="title class_">Utf8</span>               sub</span><br><span class="line">  #<span class="number">21</span> = <span class="title class_">Utf8</span>               (<span class="variable constant_">II</span>)I</span><br><span class="line">  #<span class="number">22</span> = <span class="title class_">Utf8</span>               result</span><br><span class="line">  #<span class="number">23</span> = <span class="title class_">Utf8</span>               <span class="title class_">MethodParameters</span></span><br><span class="line">  #<span class="number">24</span> = <span class="title class_">Utf8</span>               <span class="title class_">SourceFile</span></span><br><span class="line">  #<span class="number">25</span> = <span class="title class_">Utf8</span>               <span class="title class_">SimpleClass</span>.<span class="property">java</span></span><br><span class="line">  #<span class="number">26</span> = <span class="title class_">NameAndType</span>        #<span class="number">9</span>:#<span class="number">10</span>         <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">27</span> = <span class="title class_">NameAndType</span>        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// c:I</span></span><br><span class="line">  #<span class="number">28</span> = <span class="title class_">Class</span>              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">29</span> = <span class="title class_">NameAndType</span>        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">30</span> = <span class="title class_">Class</span>              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">31</span> = <span class="title class_">NameAndType</span>        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">32</span> = <span class="title class_">Utf8</span>               wz/run/<span class="title class_">SimpleClass</span></span><br><span class="line">  #<span class="number">33</span> = <span class="title class_">Utf8</span>               java/lang/<span class="title class_">Object</span></span><br><span class="line">  #<span class="number">34</span> = <span class="title class_">Utf8</span>               java/lang/<span class="title class_">System</span></span><br><span class="line">  #<span class="number">35</span> = <span class="title class_">Utf8</span>               out</span><br><span class="line">  #<span class="number">36</span> = <span class="title class_">Utf8</span>               <span class="title class_">Ljava</span>/io/<span class="title class_">PrintStream</span>;</span><br><span class="line">  #<span class="number">37</span> = <span class="title class_">Utf8</span>               java/io/<span class="title class_">PrintStream</span></span><br><span class="line">  #<span class="number">38</span> = <span class="title class_">Utf8</span>               println</span><br><span class="line">  #<span class="number">39</span> = <span class="title class_">Utf8</span>               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  private int c;</span><br><span class="line">    <span class="attr">descriptor</span>: I</span><br><span class="line">    <span class="attr">flags</span>: <span class="variable constant_">ACC_PRIVATE</span></span><br><span class="line"></span><br><span class="line">  wz.<span class="property">run</span>.<span class="title class_">SimpleClass</span>();</span><br><span class="line">    <span class="attr">descriptor</span>: ()V</span><br><span class="line">    <span class="attr">flags</span>:</span><br><span class="line">    <span class="title class_">Code</span>:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field c:I</span></span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      <span class="title class_">LineNumberTable</span>:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">4</span></span><br><span class="line">      <span class="title class_">LocalVariableTable</span>:</span><br><span class="line">        <span class="title class_">Start</span>  <span class="title class_">Length</span>  <span class="title class_">Slot</span>  <span class="title class_">Name</span>   <span class="title class_">Signature</span></span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="variable language_">this</span>   <span class="title class_">Lwz</span>/run/<span class="title class_">SimpleClass</span>;</span><br><span class="line"></span><br><span class="line">  public int <span class="title function_">add</span>();</span><br><span class="line">    <span class="attr">descriptor</span>: ()I</span><br><span class="line">    <span class="attr">flags</span>: <span class="variable constant_">ACC_PUBLIC</span></span><br><span class="line">    <span class="title class_">Code</span>:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iconst_2</span><br><span class="line">         <span class="number">3</span>: istore_2</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         <span class="number">7</span>: ireturn</span><br><span class="line">      <span class="title class_">LineNumberTable</span>:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">4</span></span><br><span class="line">      <span class="title class_">LocalVariableTable</span>:</span><br><span class="line">        <span class="title class_">Start</span>  <span class="title class_">Length</span>  <span class="title class_">Slot</span>  <span class="title class_">Name</span>   <span class="title class_">Signature</span></span><br><span class="line">            <span class="number">0</span>       <span class="number">8</span>     <span class="number">0</span>  <span class="variable language_">this</span>   <span class="title class_">Lwz</span>/run/<span class="title class_">SimpleClass</span>;</span><br><span class="line">            <span class="number">2</span>       <span class="number">6</span>     <span class="number">1</span>     a   I</span><br><span class="line">            <span class="number">4</span>       <span class="number">4</span>     <span class="number">2</span>     b   I</span><br><span class="line"></span><br><span class="line">  public int <span class="title function_">sub</span>(int, int);</span><br><span class="line">    <span class="attr">descriptor</span>: (<span class="variable constant_">II</span>)I</span><br><span class="line">    <span class="attr">flags</span>: <span class="variable constant_">ACC_PUBLIC</span></span><br><span class="line">    <span class="title class_">Code</span>:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: iload_1</span><br><span class="line">         <span class="number">1</span>: iload_2</span><br><span class="line">         <span class="number">2</span>: iadd</span><br><span class="line">         <span class="number">3</span>: aload_0</span><br><span class="line">         <span class="number">4</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field c:I</span></span><br><span class="line">         <span class="number">7</span>: isub</span><br><span class="line">         <span class="number">8</span>: istore_3</span><br><span class="line">         <span class="number">9</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">12</span>: iload_3</span><br><span class="line">        <span class="number">13</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">16</span>: iload_3</span><br><span class="line">        <span class="number">17</span>: ireturn</span><br><span class="line">      <span class="title class_">LineNumberTable</span>:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">16</span></span><br><span class="line">      <span class="title class_">LocalVariableTable</span>:</span><br><span class="line">        <span class="title class_">Start</span>  <span class="title class_">Length</span>  <span class="title class_">Slot</span>  <span class="title class_">Name</span>   <span class="title class_">Signature</span></span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">0</span>  <span class="variable language_">this</span>   <span class="title class_">Lwz</span>/run/<span class="title class_">SimpleClass</span>;</span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">1</span>     a   I</span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">2</span>     b   I</span><br><span class="line">            <span class="number">9</span>       <span class="number">9</span>     <span class="number">3</span> result   I</span><br><span class="line">    <span class="title class_">MethodParameters</span>:</span><br><span class="line">      <span class="title class_">Name</span>                           <span class="title class_">Flags</span></span><br><span class="line">      a</span><br><span class="line">      b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SourceFile</span>: <span class="string">&quot;SimpleClass.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了理解上述文件，我们将上述字节码进行结构化整理为下图，并详细讲解用途，这些是一些基础知识，只需要有个印象就行，后续实战用作为参考来查询。</p>
<p><img src="https://p.ipic.vip/269trv.jpg" alt="img"></p>
<p>（1） 魔数（Magic Number）</p>
<p>所有的.class文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE。魔数放在文件开头，JVM可以根据文件的开头来判断这个文件是否可能是一个.class文件，如果是，才会继续进行之后的操作。</p>
<p>（2） 版本号</p>
<p>版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。</p>
<p>（3） 常量池（Constant Pool）</p>
<p>紧接着主版本号之后的字节为常量池入口。常量池中存储两类常量：字面量与符号引用。字面量为代码中声明为Final的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。</p>
<p>常量池整体上分为两部分：常量池计数器(cp_info_count)以及常量池数据区(cp_info 集合)，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8441e9f01fa644aa8d3b91c1e8197221~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<p> 常量池的每一行的结构都是上图中的 cp_info，更多 cp_info 信息见附录中的 cp_info 类型。</p>
<p>以上面 SimpleClass.class 为例，大致可以分为下面几类：</p>
<p>（4） 访问标志</p>
<p>常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰。JVM规范规定了如下图的访问标志（Access_Flag）。</p>
<img src="https://p.ipic.vip/xdshrn.jpg" height="50%" width="50%"/>

<p>（5） 当前类名</p>
<p>访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。</p>
<p>（6） 父类名称</p>
<p>当前类名后的两个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。</p>
<p>（7） 接口信息</p>
<p>父类名称后为两字节的接口计数器，描述该类或父类实现接口数量。紧接着的n个字节是所有接口名称的字符串常量的索引值。</p>
<p>（8） 字段表</p>
<p>字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info。</p>
<p>（9）方法表</p>
<p>字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数，第二个部分为每个方法的详细信息。方法的详细信息包括：方法的访问标志、方法名、方法的描述符以及方法的属性，如图所示:</p>
<p><img src="https://p.ipic.vip/r2l9fk.jpg" alt="img"></p>
<p>方法名和方法的描述符都是常量池的索引值，可以通过索引值在常量池中查询得到。而方法属性我们可以拿刚刚的字节码文件举例。</p>
<p><img src="https://p.ipic.vip/kkjrdy.jpg" alt="img"></p>
<p>文件里我们可以看到属性中包含2个部分:</p>
<ul>
<li><strong>Code 区</strong>: 源代码对应的 JVM 指令操作码，我们在字节码增强的时候重点操作的就是这个部分。</li>
<li><strong>LineNumberTable</strong>: 型号表，将 Code 区的操作码和源代码的行号对应，Debug 时会起到作用（即: 当源代码向下走一行，相应的需要走几个 JVM 指令操作码）。</li>
</ul>
<p>一般情况下还会包括本地变量表。</p>
<ul>
<li><strong>LocalVariableTable</strong>: 本地变量表，包含 this 和局部变量，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。</li>
</ul>
<p>（10）附加属性表</p>
<p>字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。</p>
<h4 id="5、字节码执行"><a href="#5、字节码执行" class="headerlink" title="5、字节码执行"></a>5、字节码执行</h4><p>字节码指令执行的数据结构就是<strong>栈帧（stack frame）</strong>，也就是在虚拟机栈中的栈元素，虚拟机会为每个方法分配一个栈帧，因为虚拟机栈是 LIFO(后进先出)的，所以当前线程正在活动的栈帧，也就是栈顶的栈帧，JVM 规范中称之为“CurrentFrame”,这个当前栈帧对应的方法就是“CurrentMethod“，JVM 的运行时数据区的结构如下图：</p>
<p><img src="https://p.ipic.vip/k73p1q.jpg" alt="img"></p>
<p>主要的数据结构有4个部分，局部变量区，操作数栈，动态链接，方法的返回地址。</p>
<ul>
<li><strong>局部变量表</strong></li>
</ul>
<p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<ul>
<li><strong>操作数栈</strong></li>
</ul>
<p>Java 虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指－操作数栈。操作数栈同局部变量表一样，也是编译期间就能决定了其存储空间（最大的单位长度），通过 Code 属性存储在类或接口的字节流中。操作数栈也是个 LIFO 栈。 它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如 int、long、float、double、reference 和 returnType 的存储。对于 byte、short 以及 char 类型的值在压入到操作数栈之前，也会被转换为 int。</p>
<ul>
<li><strong>动态链接</strong></li>
</ul>
<p>动态链接就是将符号引用所表示的方法，转换成方法的直接引用。加载阶段或第一次使用时转化为直接引用的（将变量的访问转化为访问这些变量的存储结构所在的运行时内存位置）就叫做静态解析。JVM 的动态链接还支持运行期转化为直接引用。也可以叫做 Late Binding,晚期绑定。动态链接是 java 灵活 OO 的基础结构。第一次运行时，会根据字符串的内容，到该类的方法表中搜索这个方法。运行一次之后，符号引用会被替换为直接引用，下次就不用搜索了。直接引用就是偏移量，通过偏移量虚拟机可以直接在该类的内存区域中找到方法字节码的起始位置。重写就是动态链接，重载就是静态解析。</p>
<ul>
<li><strong>方法返回地址</strong></li>
</ul>
<p>方法正常退出，JVM 执行引擎会恢复上层方法局部变量表操作数栈并把返回值压入调用者的栈帧的操作数栈，PC 计数器的值就会调整到方法调用指令后面的一条指令。这样使得当前的栈帧能够和调用者连接起来，并且让调用者的栈帧的操作数栈继续往下执行。</p>
<h4 id="6、总结："><a href="#6、总结：" class="headerlink" title="6、总结："></a>6、总结：</h4><p>1、本节当中并没有涉及到“技术性”的知识点，因此也不需要“记忆”任何内容，只需要当作字典来参考就够了。</p>
<p>2、作为学习无埋点上报的基础，需要重点记忆的内容如下</p>
<table>
<thead>
<tr>
<th>类目</th>
<th>重点记忆</th>
</tr>
</thead>
<tbody><tr>
<td>操作数栈</td>
<td>操作数栈是个 LIFO 栈。 它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。</td>
</tr>
<tr>
<td>访问标志</td>
<td>描述该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰</td>
</tr>
<tr>
<td>常量入栈</td>
<td>记住栈帧（stack frame）的原理</td>
</tr>
<tr>
<td>变量入栈</td>
<td>记住栈帧（stack frame）的原理</td>
</tr>
<tr>
<td>CurrentMethod</td>
<td>ASM API中经常有这个字段</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>ASM API中经常有这个字段，本地变量表，<strong>包含 this 和局部变量</strong>，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="Gradle插件"><a href="#Gradle插件" class="headerlink" title="Gradle插件"></a>Gradle插件</h4><p>Gradle本身只是提供了基本的核心功能，其他的特性比如编译Java源码的能力，编译Android工程的能力等等就需要通过插件来实现了。要想应用插件，需要把插件应用到项目中，应用插件通过 Project.apply() 方法来完成。</p>
<p>插件开发有三种方式Build Script、buildSrc project和Standalone project，前两者都只能在项目内使用，因此选择最后一种Standalone project开发模式，可以将模块发布到maven供其他项目使用。</p>
<p><strong>配置Gradle与创建插件</strong></p>
<p>在项目工程中新建一个Java&#x2F;Kotlin Library模块，在插件模块的build.gradle文件中添加依赖<code>gradleApi</code>依赖，用于开发插件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation gradleApi()</span><br></pre></td></tr></table></figure>

<p>为了方便打包和发布插件，推荐使用<a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/java_gradle_plugin.html#java_gradle_plugin">Java Gradle Plugin Development Plugin</a>，在plugins中引入<code>java-gradle-plugin</code>和<code>maven-publish</code>插件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java-gradle-plugin&#x27;</span> <span class="comment">//用于打包插件</span></span><br><span class="line">    id <span class="string">&#x27;maven-publish&#x27;</span> <span class="comment">//用于发布插件到Maven仓库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在插件模块中新建一个插件类MockPlugin，继承自<code>org.gradle.api.Plugin</code>，并实现<code>apply</code>方法。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.Dummyplugins</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DummyPlugins</span> : Plugin&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">override fun apply(<span class="attr">project:</span> Project) &#123;</span><br><span class="line">    project.task(<span class="string">&quot;DummyPlugins&quot;</span>).doLast &#123;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m Dummy plugins!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写插件类后，需要在插件模块的build.gradle文件中声明插件信息，以便打包插件（Java Gradle Plugin Development Plugin）获取相关信息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件构建和发布相关配置</span></span><br><span class="line">gradlePlugin &#123;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        <span class="comment">// 声明插件信息，这里的 myCustomPlugin 名字随意</span></span><br><span class="line">        myCustomPlugin &#123;</span><br><span class="line">            <span class="comment">// 插件ID</span></span><br><span class="line">            id = <span class="string">&#x27;com.my.dummyplugins.DummyPlugins&#x27;</span></span><br><span class="line">            <span class="comment">// 插件的实现类</span></span><br><span class="line">            implementationClass = <span class="string">&#x27;com.my.dummyplugins.DummyPlugins&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了发布插件，还需定义插件发布的信息，包括插件的名称、版本、描述、作者等信息。</p>
<p><strong>使用插件</strong></p>
<p>在其他工程中，通过<code>classpath</code>引入插件，然后在<code>plugins</code>中引入插件，即可使用插件中的功能。<br>在项目根目录的build.gradle文件中，添加插件仓库地址</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url(<span class="string">&#x27;file://your/repo/&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>在项目根目录的build.gradle文件的buildscript的dependencies中通过classspath引入插件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">// 自定义插件</span></span><br><span class="line">        classpath <span class="string">&#x27;com.my.dummyplugins:DummyPlugins:0.0.1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用插件模块的build.gradle文件中，添加插件依赖</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;com.my.dummyplugins&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="4、全文总结"><a href="#4、全文总结" class="headerlink" title="4、全文总结"></a>4、全文总结</h2><p>本文章是一些很基础的ASM基础，便于大家作为入门以及知识储备的学习，后续文章中会在实战的角度介绍如何插桩。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://asm.ow2.io/">https://asm.ow2.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903693553238023">https://juejin.cn/post/6844903693553238023</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/lsieun/2924433">https://blog.51cto.com/lsieun/2924433</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2028052">https://cloud.tencent.com/developer/article/2028052</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/23/%E4%BB%8E%E9%9B%B6%E5%8D%95%E5%AD%A6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A52-ASM%20Transform%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="christiecui">
      <meta itemprop="description" content="终身学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Christiecui的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/23/%E4%BB%8E%E9%9B%B6%E5%8D%95%E5%AD%A6%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A52-ASM%20Transform%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">从零单学跨平台无埋点上报2-ASMTransform实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-23 11:36:53" itemprop="dateCreated datePublished" datetime="2023-08-23T11:36:53+08:00">2023-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:58:46" itemprop="dateModified" datetime="2023-11-03T16:58:46+08:00">2023-11-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从零单学跨平台无埋点上报2-ASM-Transform实战"><a href="#从零单学跨平台无埋点上报2-ASM-Transform实战" class="headerlink" title="从零单学跨平台无埋点上报2-ASM Transform实战"></a>从零单学跨平台无埋点上报2-ASM Transform实战</h1><h2 id="一、Previous-Review"><a href="#一、Previous-Review" class="headerlink" title="一、Previous Review"></a>一、Previous Review</h2><p>字节码增强的原理就是通过Transform将class文件，通过Gradle Task进行流水线读取与处理，并写回下一个Transform中</p>
<img src="https://p.ipic.vip/npbw4v.png" alt="image-20230705105542384" style="zoom: 20%;" />

<p>因此本文将分析进行class的改写与实战，根据下图</p>
<p><img src="https://p.ipic.vip/zn69jc.png" alt="image-20230922201450418"></p>
<h2 id="二、核心API选择"><a href="#二、核心API选择" class="headerlink" title="二、核心API选择"></a>二、核心API选择</h2><h3 id="1、-前言："><a href="#1、-前言：" class="headerlink" title="1、 前言："></a>1、 前言：</h3><p>Transform API 是 AGP1.5 就引入的特性，主要用于在 Android 构建过程中，在 Class转Dex的过程中修改 Class 字节码。利用 Transform API，我们可以拿到所有参与构建的 Class 文件，然后可以借助ASM 等字节码编辑工具进行修改，插入自定义逻辑。</p>
<p>国内很多团队都或多或少的用 AGP 的 Transform API 来搞点儿黑科技，比如无痕埋点，耗时统计，方法替换等。但是在AGP7.0中Transform已经被标记为废弃了，替换为AsmClassVisitorFactory，并且将在AGP8.0中移除。</p>
<p>开门见山，两者对比如下</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>AsmClassVisitorFactory（建议）</td>
<td>1、性能提升 18%<br />2、代码量减少5倍，使用简单，做了大量封装</td>
<td>1、因为高度封装，最新的版本由于扫描规则，会有一些jar包扫不到，进而无法处理，不过相信会优化<br />具体可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/7190196880469393463">https://juejin.cn/post/7190196880469393463</a></td>
</tr>
<tr>
<td>Transform Action</td>
<td>1、可操作类较多，可以定制遍历规则，当前覆盖较全</td>
<td>1、实现复杂</td>
</tr>
</tbody></table>
<h3 id="2、Transform-Action-方案描述-（选读）（AGP-lt-7-0）"><a href="#2、Transform-Action-方案描述-（选读）（AGP-lt-7-0）" class="headerlink" title="2、Transform Action 方案描述 （选读）（AGP &lt; 7.0）"></a>2、Transform Action 方案描述 （选读）（AGP &lt; 7.0）</h3><h4 id="1）介绍"><a href="#1）介绍" class="headerlink" title="1）介绍"></a>1）介绍</h4><p>Transform API是由AGP提供的，而Transform Action则是由Gradle提供。不光是 AGP 需要 Transform，Java 也需要，所以由 Gradle 来提供统一的 Transform API 也合情合理。</p>
<h4 id="2）原理："><a href="#2）原理：" class="headerlink" title="2）原理："></a>2）原理：</h4><p>为了更好的理解，因为AsmClassVisitor是transform的高度封装，这里详细介绍下原理</p>
<p>【插桩过程】</p>
<img src="https://p.ipic.vip/im3cva.png" alt="image-20231101153717441" style="zoom: 33%;" />

<p>【ASM架构】</p>
<img src="https://p.ipic.vip/lagi6n.jpg" alt="img" style="zoom:39%;" />



<p>核心API解释：</p>
<ul>
<li>ClassVisitor（抽象类）：ClassReader 对象创建之后，调用 ClassReader#accept() 方法，传入一个 ClassVisitor 对象。在 ClassReader 中遍历树结构的不同节点时会调用 ClassVisitor 对象中不同的 visit() 方法，从而实现对字节码的修改。在 ClassVisitor 中的一些访问会产生子过程，比如 visitMethod 会产生 MethodVisitor 的调用，visitField 会产生对 FieldVisitor 的调用，用户可以对这些 Visitor 进行自己的实现，从而达到对这些子节点的字节码的访问和修改。</li>
<li>ASM Core API可以类比解析XML文件中的SAX方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用Core API。在Core API中有以下几个关键类：</li>
<li>ClassReader：它将字节数组或者 class 文件读入到内存当中，并以树的数据结构表示，树中的一个节点代表着 class 文件中的某个区域。可以将 ClassReader 看作是 Visitor 模式中的访问者的实现类。</li>
<li>ClassWriter：ClassVisitor 的实现类，它是生成字节码的工具类，它一般是责任链中的最后一个节点，其之前的每一个 ClassVisitor 都是致力于对原始字节码做修改，而 ClassWriter 的操作则是把每一个节点修改后的字节码输出为字节数组。</li>
<li>ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。</li>
</ul>
<p>【ASM Tree API介绍】</p>
<img src="https://p.ipic.vip/0niaez.jpg" alt="img" style="zoom:50%;" />

<p>getName()  用于指定 Transform 的名字，对应了该 Transform 所代表的 Task 的名称</p>
<p>getInputTypes()  用于指定 Transform 的输入类型，可以作为输入过滤的一种手段</p>
<p>getScopes()  用于指定 Transform 的作用域 </p>
<p>transform() 真正修改字节码的方法</p>
<p>getInputTypes()，getScopes()，这个要多说几句，对于上面的transform图，只是展示Transform的其中一种情况。而Transform其实可以有两种输入，一种是消费型的，当前Transform需要将消费型型输出给下一个Transform，另一种是引用型的，当前Transform可以读取这些输入，而不需要输出给下一个Transform，比如Instant Run就是通过这种方式，检查两次编译之间的diff的。而Scope和contentType是transform输入的两种过滤机制，如下</p>
<img src="https://p.ipic.vip/dpw64i.jpg" alt="img" style="zoom:67%;" />



<p>ContentType，顾名思义，就是数据类型，在插件开发中，我们一般只能使用CLASSES和RESOURCES两种类型，注意，其中的CLASSES已经包含了class文件和jar文件。 ContentType与Scope是两个维度</p>
<p>【插桩过程】</p>
<p>当已经遍历到class时，可以通过如下的流程，进行ASM Hook</p>
<img src="https://p.ipic.vip/hkfl82.png" alt="image-20231031194718832" style="zoom:66%;" />





<h3 id="1、AsmClassVisitorFactory-（AGP-gt-x3D-7-0）"><a href="#1、AsmClassVisitorFactory-（AGP-gt-x3D-7-0）" class="headerlink" title="1、AsmClassVisitorFactory （AGP &gt;&#x3D; 7.0）"></a>1、AsmClassVisitorFactory （AGP &gt;&#x3D; 7.0）</h3><h4 id="1）介绍-1"><a href="#1）介绍-1" class="headerlink" title="1）介绍"></a>1）介绍</h4><p>AGP很贴心的为我们又做了一层封装，提供了AsmClassVisitorFactory来方便我们使用Transform Action进行ASM操作。</p>
<h4 id="2）原理"><a href="#2）原理" class="headerlink" title="2）原理"></a>2）原理</h4><p>在进入Gradle7.0 后，基于Gradle7.0 自定义的 <code>Plugin</code> 插件，处理 <code>Asm</code> 的代码插桩是非常简单的事情。<strong>我们只要关心查找和插桩代码就行了，</strong>把要修改的类找出来，在类对应的方法中 插入业务代码。因此会省去很多原理和逻辑的解释。</p>
<p>【插桩过程】相比transform api，AsmClassVisitorFactory只需要关注对class的操作即可，不必关注transform，文件夹，jar包的扫描，解压，copy等过程，以及增量编译，极大简化了学习成本。</p>
<img src="https://p.ipic.vip/bl9h0f.png" alt="image-20231101154918954" style="zoom: 50%;" />

<h4 id="3）使用示例"><a href="#3）使用示例" class="headerlink" title="3）使用示例"></a>3）使用示例</h4><p>【Demo演示】先介绍简单的使用方法举例：示例代码</p>
<img src="https://p.ipic.vip/qq20v0.jpg" alt="image.png" style="zoom:67%;" />

<p>【方案步骤】</p>
<p>第一步：定义一个插件，这个在《ASM 准备知识》讲过，就不再阐述</p>
<p>第二步： 处理 DemoPlugin</p>
<img src="https://p.ipic.vip/168ga9.jpg" alt="image.png" style="zoom: 50%;" />

<p>插件要对应的在 <code>com.android.application</code> 中添加</p>
<p>调用 <code>variant.instrumentation</code> 的  <code>transformClassesWith</code> 方法添加我们处理class 的 <code>Factory</code></p>
<p>设置 <code>setAsmFramesComputationMode</code>  模式</p>
<p>第三步 AsmClassVisitorFactory</p>
<img src="https://p.ipic.vip/wswkib.jpg" alt="image.png" style="zoom:67%;" />

<ul>
<li>在 <code>AsmClassVisitorFactory</code> 的 <code>isInstrumentable</code> 方法中，所有class 类都会在这里被扫描到，依据这个，我们可以过滤出对应的 class ,添加到集合里面，返回 true ,即表示要进行代码手术了。</li>
<li><code>createClassVisitor</code> 是 <code>isInstrumentable</code> 方法之后被调用的，在这里进行代码手术，可以自定义一个 <code>ModuleClassVisitor</code> 继承 <code>ClassVisitor</code></li>
</ul>
<img src="https://p.ipic.vip/qak3kq.jpg" alt="image.png" style="zoom:67%;" />

<ul>
<li>在 <code>visitCode</code> 方法中， class 类会在这里处理，也是手术的关键。这里 asm 的使用细节暂不多说。</li>
</ul>
<img src="https://p.ipic.vip/clphzk.jpg" alt="image.png" style="zoom:67%;" />





<h2 id="三、实战"><a href="#三、实战" class="headerlink" title="三、实战"></a>三、实战</h2><p>按照实战的思路，从三个步骤入手</p>
<ul>
<li>我该用什么API操作类</li>
<li>我该在哪插入代码</li>
<li>我该如何插入代码</li>
<li>我该如何加速编写代码</li>
</ul>
<h3 id="1、我该用什么API操作类：API的选择"><a href="#1、我该用什么API操作类：API的选择" class="headerlink" title="1、我该用什么API操作类：API的选择"></a>1、我该用什么API操作类：API的选择</h3><ul>
<li><p>AdviceAdapter</p>
<p>对于AdviceAdapter类来说，能够很容易的实现在“方法进入”和“方法退出”时添加代码。AdviceAdapter类的特点：引入了onMethodEnter()方法和onMethodExit()方法。</p>
</li>
<li><p>GeneratorAdapter</p>
<p>对于GeneratorAdapter类来说，它非常重要的一个特点：将一些visitXxxInsn()方法封装成一些常用的方法。</p>
</li>
<li><p>LocalVariablesSorter</p>
<p>对于LocalVariablesSorter类来说，它的特点是“可以引入新的局部变量，并且能够对局部变量重新排序”。</p>
</li>
<li><p>MethodVisitor</p>
<p>操作方法的抽象类</p>
</li>
</ul>
<p>其继承关系如下</p>
<img src="/Users/cao884203/Library/Application Support/typora-user-images/image-20231101194538898.png" alt="image-20231101194538898" style="zoom:50%;" />

<h3 id="2、我该在哪插入代码：生命周期了解"><a href="#2、我该在哪插入代码：生命周期了解" class="headerlink" title="2、我该在哪插入代码：生命周期了解"></a>2、我该在哪插入代码：生命周期了解</h3><p><img src="https://p.ipic.vip/k1g7m8.jpg" alt="img"></p>
<p><strong>用的比较多的是</strong></p>
<ul>
<li>visit</li>
<li>visitField</li>
<li>visitMethod</li>
<li>visitEnd</li>
</ul>
<p>遍历生命周期顺序是</p>
<p><strong>visitInvokeDynamicInsn -&gt;  visitCode -&gt; visitInsn -&gt; visitEnd</strong> </p>
<h3 id="3、我该如何插入代码：插入一个log试试"><a href="#3、我该如何插入代码：插入一个log试试" class="headerlink" title="3、我该如何插入代码：插入一个log试试"></a>3、我该如何插入代码：插入一个log试试</h3><p>先查看一个简单方法介绍，假如我们要向testMethod 插入一个<code> Log.i(&quot;testMethod&quot;,&quot;testMethod in&quot;)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//Log.i(&quot;testMethod&quot;,&quot;Hello ASM&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该方法为字节码，应该是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// access flags 0x12</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="title function_">testMethod</span><span class="params">()</span>V</span><br><span class="line">    LDC <span class="string">&quot;TAG&quot;</span></span><br><span class="line">    LDC <span class="string">&quot;testMethod in&quot;</span></span><br><span class="line">    INVOKESTATIC android/util/Log.i (Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line">    POP</span><br><span class="line">    <span class="type">RETURN</span></span><br><span class="line">    <span class="variable">MAXSTACK</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么ASM Hook就要写如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methodVisitor.visitLdcInsn(<span class="string">&quot;TAG&quot;</span>);</span><br><span class="line">methodVisitor.visitLdcInsn(<span class="string">&quot;Hello ASM&quot;</span>);</span><br><span class="line">methodVisitor.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;android/util/Log&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;)I&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">methodVisitor.visitInsn(POP);</span><br></pre></td></tr></table></figure>

<ul>
<li>加载常量”tag”入栈</li>
<li>加载常量”Hello ASM”入栈</li>
<li>执行Log的静态方法d (INVOKESTATIC 是静态的opcode)</li>
<li>方法调用出栈</li>
</ul>
<h3 id="4、我该如何加速编写代码：常用参数助记与工具"><a href="#4、我该如何加速编写代码：常用参数助记与工具" class="headerlink" title="4、我该如何加速编写代码：常用参数助记与工具"></a>4、我该如何加速编写代码：常用参数助记与工具</h3><h4 id="1）常用参数"><a href="#1）常用参数" class="headerlink" title="1）常用参数"></a>1）常用参数</h4><p><strong>opcode常用</strong></p>
<p><img src="https://p.ipic.vip/a51lgs.png" alt="image-20230726210217712"></p>
<p><img src="https://s2.51cto.com/images/20210821/1629535019505703.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="Java ASM系列：（056）opcode: method_ASM"></p>
<p><em><strong>这里还有几个比较常用的方法，可以记忆下</strong></em></p>
<ul>
<li><p>visitLdcInsn 常量入栈</p>
</li>
<li><p>visitVarInsn 局部变量入栈</p>
</li>
<li><p>accept(class visitor)</p>
</li>
<li><p>LSTORE 命令字 栈顶long数值存入第1局部变量</p>
</li>
<li><p>DUP 使用 用于赋值栈顶的指定个数的数值，并将其压入栈顶指定次数；</p>
</li>
<li><p>LSUB 使用 运算指令</p>
</li>
<li><p>POP 使用：栈顶数值出栈(不能是long&#x2F;double)</p>
</li>
<li><p>visitCode是方法的访问开始；</p>
</li>
<li><p>visitInsn可以访问方法的操作指令，一般应用于在return指令之前插入代码；</p>
</li>
<li><p>vistiMax则用于复写操作数栈和局部变量表的大小，因为类被修改，所以所需的栈和变量表大小可能会增加</p>
</li>
</ul>
<p>比如：在插入&#x2F;Log.i(“testMethod”,”Hello ASM”) 之前</p>
<p><img src="https://p.ipic.vip/9xw8qn.png" alt="image-20231101195352022"></p>
<p>插入之后</p>
<p><img src="https://p.ipic.vip/phk7qf.png" alt="image-20231101195412558"></p>
<p>可以参考java指令集</p>
<p><a target="_blank" rel="noopener" href="https://gityuan.com/2015/10/24/jvm-bytecode-grammar/">https://gityuan.com/2015/10/24/jvm-bytecode-grammar/</a></p>
<h4 id="2）工具"><a href="#2）工具" class="headerlink" title="2）工具"></a>2）工具</h4><p>工具可以大大提高编写效率，如果是Android Studio，这里强烈推荐ASM Bytecode Viewer</p>
<p><img src="https://p.ipic.vip/o3737z.png" alt="image-20231101193608291"></p>
<p>在你不知道如何该写ASM字节码的时候，你可以写Java或者KT code，用它来参考生成字节码</p>
<p><img src="https://p.ipic.vip/xo739b.png" alt="image-20231101193709051"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="四、全文总结"><a href="#四、全文总结" class="headerlink" title="四、全文总结"></a>四、全文总结</h2><p>本文介绍了：ASM 框架的选择、AsmClassVisitorFactory的使用</p>
<p>接下来从实战层面介绍了：</p>
<ul>
<li>我该用什么API操作类</li>
<li>我该在哪插入代码</li>
<li>我该如何插入代码</li>
<li>我该如何加速编写代码</li>
</ul>
<p>后续的文章会介绍对于一些语法糖Hook不到情况的进阶hook</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://gityuan.com/2015/10/24/jvm-bytecode-grammar/">https://gityuan.com/2015/10/24/jvm-bytecode-grammar/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16163480/6511302">https://blog.51cto.com/u_16163480/6511302</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7190196880469393463">https://juejin.cn/post/7190196880469393463</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7207713058855469115">https://juejin.cn/post/7207713058855469115</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/lsieun/2924583">https://blog.51cto.com/lsieun/2924583</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">christiecui</p>
  <div class="site-description" itemprop="description">终身学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">christiecui</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
